diff --git a/doc/src/api.md b/doc/src/api.md
index f190dc160..e77d85cf3 100644
--- a/doc/src/api.md
+++ b/doc/src/api.md
@@ -955,6 +955,11 @@ Embree API Reference
 ```
 \pagebreak
 
+## rtcExtractBVH
+``` {include=src/api/rtcExtractBVH.md}
+```
+\pagebreak
+
 Performance Recommendations
 ===========================
 
diff --git a/doc/src/api/rtcExtractBVH.md b/doc/src/api/rtcExtractBVH.md
new file mode 100644
index 000000000..3c34c0ce2
--- /dev/null
+++ b/doc/src/api/rtcExtractBVH.md
@@ -0,0 +1,94 @@
+% rtcExtractBVH(3) | Embree Ray Tracing Kernels 3
+
+#### NAME
+
+    rtcExtractBVH - Extract BVH from a scene
+
+#### SYNOPSIS
+
+    #include <embree3/rtcore_builder.h>
+
+    struct BVHPrimitive
+    {
+      unsigned int geomID;
+      unsigned int primID;
+    };
+  
+    struct RTCBVHExtractFunction
+    {
+      void (*expectedSize) (unsigned int num_leaf, unsigned int num_tri, void *userData);
+  
+      void* (*createLeaf) (unsigned int nbPrim, const BVHPrimitive prims[], void *userData);
+      void* (*createInstance) (unsigned int nbPrim, const unsigned int geomID[], void *userData);
+      void* (*createCurve) (unsigned int nbPrim, const BVHPrimitive prims[], void *userData);
+  
+      void* (*createInnerNode) (unsigned int nbChild, void* children[], void *userData);
+  
+      void (*setAlignedBounds) (void *node, const RTCBounds &bounds, void *userData);
+      void (*setLinearBounds) (void *node, const RTCLinearBounds &lbounds, void *userData);
+      void (*setUnalignedBounds) (void *node, const RTCAffineSpace &affSpace, void *userData);
+      void (*setUnalignedLinearBounds) (void *node, const RTCAffineSpace &affSpace, const RTCBounds &bounds, void *userData);
+    };
+
+    void* rtcExtractBVH(
+      RTCScene hscene,
+      RTCBVHExtractFunction args,
+      void *userData
+    );
+
+#### DESCRIPTION
+
+The `rtcExtractBVH` function can be used to extract the BVH tree from a scene
+that has already been built.
+
+The `rtcExtractBVH` take the scene to export as parameter as well as a
+structure that contain callback function pointers and a user-defined pointer
+that is passed to all callback functions when invoked.
+All callback functions are typically called from a multiple threads, thus
+their implementation must be thread-safe.
+
+At least 8 callback functions must be registered, which are invoked during
+build to create BVH leaf (`createLeaf`, `createInstance` and `createCurve`
+member), to create a BVH inner node (`createInnerNode` member) and to set the
+bounding boxes of a node (`setAlignedBounds`, `setLinearBounds`,
+`setUnalignedBounds` and `setUnalignedLinearBounds` member).
+
+The function pointer used to preallocate buffer (`expectedSize` member) is
+optional and may be `NULL`.
+
+The `createLeaf`, `createInstance` and `createCurve` callback also gets the
+number of primitives for this leaf, and an array of size `nbPrim` of
+primitive objects.
+
+The `createInnerNode` callback gets the number of child, as well as an array
+of `nbChild` child previously returned by either `createLeaf`,
+`createInstance` or `createCurve`.
+
+The `setAlignedBounds`, `setLinearBounds`, `setUnalignedBounds` and
+`setUnalignedLinearBounds` callback function gets a pointer to the node as
+input (`node` argument) as well as the bounds for this node.
+
+The `setAlignedBounds` callback function take bounds of type `RTCBounds` which
+represent an aligned bound box.
+
+The `setLinearBounds` callback function take bounds of type `RTCLinearBounds`
+which represent an aligned bound box that can be linearly interpolated over
+time.
+
+The `setUnalignedBounds` callback function take bounds of type `RTCAffineSpace`
+which represent an affine space in which the bound are ((0, 0, 0), (1, 1, 1)).
+
+The `setUnalignedLinearBounds` callback function take bounds of type
+`RTCAffineSpace` and `RTCBounds`. The bound box in the affine space described
+by `affSpace` are the linear interpolation between ((0, 0, 0), (1, 1, 1)) and
+`bounds`.
+
+#### EXIT STATUS
+
+Return the root node, returned by the root `createInnerNode`, or `NULL` if an
+error occurred.
+On failure an error code is set that can be queried using `rtcDeviceGetError`.
+
+#### SEE ALSO
+
+[rtcCommitScene]
diff --git a/include/embree3/rtcore_builder.h b/include/embree3/rtcore_builder.h
index af84035b0..3f2c4eddf 100644
--- a/include/embree3/rtcore_builder.h
+++ b/include/embree3/rtcore_builder.h
@@ -131,6 +131,35 @@ RTC_API void rtcRetainBVH(RTCBVH bvh);
 /* Releases the BVH (decrements reference count). */
 RTC_API void rtcReleaseBVH(RTCBVH bvh);
 
+struct BVHPrimitive {
+    unsigned int geomID;
+    unsigned int primID;
+};
+
+struct RTCBVHExtractFunction
+{
+  /**
+   * Allow to preallocate buffer, is called before everything else
+   * Can be NULL if not used
+   */
+  void (*expectedSize) (unsigned int num_leaf, unsigned int num_tri, void *userData);
+
+  // Leaf creator function
+  void* (*createLeaf) (unsigned int nbPrim, const BVHPrimitive prims[], void *userData);
+  void* (*createInstance) (unsigned int nbPrim, const unsigned int geomID[], void *userData);
+  void* (*createCurve) (unsigned int nbPrim, const BVHPrimitive prims[], void *userData);
+
+  // InnerNode creator function
+  void* (*createInnerNode) (unsigned int nbChild, void* children[], void *userData);
+
+  void (*setAlignedBounds) (void *node, const RTCBounds &bounds, void *userData);
+  void (*setLinearBounds) (void *node, const RTCLinearBounds &lbounds, void *userData);
+  void (*setUnalignedBounds) (void *node, const RTCAffineSpace &affSpace, void *userData);
+  void (*setUnalignedLinearBounds) (void *node, const RTCAffineSpace &affSpace, const RTCBounds &bounds, void *userData);
+};
+
+RTC_API void *rtcExtractBVH(RTCScene hscene, RTCBVHExtractFunction args, void *userData);
+
 #if defined(__cplusplus)
 }
 #endif
diff --git a/include/embree3/rtcore_common.h b/include/embree3/rtcore_common.h
index 29dfcba11..7eb21c28c 100644
--- a/include/embree3/rtcore_common.h
+++ b/include/embree3/rtcore_common.h
@@ -191,6 +191,13 @@ struct RTC_ALIGN(16) RTCLinearBounds
   struct RTCBounds bounds1;
 };
 
+/* AffineSpace representation */
+struct RTC_ALIGN(16) RTCAffineSpace
+{
+  float linear[3*3];
+  float affine[3];
+};
+
 /* Intersection context flags */
 enum RTCIntersectContextFlags
 {
diff --git a/kernels/bvh/bvh_builder_hair.cpp b/kernels/bvh/bvh_builder_hair.cpp
index 14273787f..cad238123 100644
--- a/kernels/bvh/bvh_builder_hair.cpp
+++ b/kernels/bvh/bvh_builder_hair.cpp
@@ -135,8 +135,9 @@ namespace embree
 #if defined(__AVX__)
     Builder* BVH8Curve8vBuilder_OBB_New   (void* bvh, Scene* scene, size_t mode) { return new BVHNHairBuilderSAH<8,Curve8v,Line8i>((BVH8*)bvh,scene); }
     Builder* BVH4Curve8iBuilder_OBB_New   (void* bvh, Scene* scene, size_t mode) { return new BVHNHairBuilderSAH<4,Curve8i,Line8i>((BVH4*)bvh,scene); }
-#endif
 
+    unsigned int getLine8iPrimId(Line8i *line, unsigned int i) { return line->primID(i); }
+#endif
   }
 }
 #endif
diff --git a/kernels/common/rtcore_builder.cpp b/kernels/common/rtcore_builder.cpp
index 56858294c..6a154881b 100644
--- a/kernels/common/rtcore_builder.cpp
+++ b/kernels/common/rtcore_builder.cpp
@@ -29,8 +29,18 @@
 #include "../builders/bvh_builder_sah.h"
 #include "../builders/bvh_builder_morton.h"
 
+#include "../bvh/bvh.h"
+#include "../geometry/instance.h"
+#include "../geometry/trianglev.h"
+#include "../geometry/trianglei.h"
+#include "../geometry/curveNi.h"
+#include "../geometry/curveNi_mb.h"
+#include "../geometry/linei.h"
+
 namespace embree
 { 
+  DECLARE_ISA_FUNCTION(unsigned int, getLine8iPrimId, Line8i* COMMA unsigned int);
+
   namespace isa // FIXME: support more ISAs for builders
   {
     struct BVH : public RefCount
@@ -334,92 +344,362 @@ namespace embree
       return root;
     }
 
-    RTC_API void* rtcBuildBVH(const RTCBuildArguments* arguments)
-    {
-      BVH* bvh = (BVH*) arguments->bvh;
-      RTC_CATCH_BEGIN;
-      RTC_TRACE(rtcBuildBVH);
-      RTC_VERIFY_HANDLE(bvh);
-      RTC_VERIFY_HANDLE(arguments);
-      RTC_VERIFY_HANDLE(arguments->createNode);
-      RTC_VERIFY_HANDLE(arguments->setNodeChildren);
-      RTC_VERIFY_HANDLE(arguments->setNodeBounds);
-      RTC_VERIFY_HANDLE(arguments->createLeaf);
-
-      if (arguments->primitiveArrayCapacity < arguments->primitiveCount)
-        throw_RTCError(RTC_ERROR_INVALID_ARGUMENT,"primitiveArrayCapacity must be greater or equal to primitiveCount")
-
-      /* initialize the allocator */
-      bvh->allocator.init_estimate(arguments->primitiveCount*sizeof(BBox3fa));
-      bvh->allocator.reset();
-
-      /* switch between differnet builders based on quality level */
-      if (arguments->buildQuality == RTC_BUILD_QUALITY_LOW)
-        return rtcBuildBVHMorton(arguments);
-      else if (arguments->buildQuality == RTC_BUILD_QUALITY_MEDIUM)
-        return rtcBuildBVHBinnedSAH(arguments);
-      else if (arguments->buildQuality == RTC_BUILD_QUALITY_HIGH) {
-        if (arguments->splitPrimitive == nullptr || arguments->primitiveArrayCapacity <= arguments->primitiveCount)
-          return rtcBuildBVHBinnedSAH(arguments);
-        else
-          return rtcBuildBVHSpatialSAH(arguments);
-      }
-      else
-        throw_RTCError(RTC_ERROR_INVALID_OPERATION,"invalid build quality");
+    template<int N>
+    void* createLeaf(const typename BVHN<N>::NodeRef node,
+                     const PrimitiveType *leafType,
+                     const RTCBVHExtractFunction args,
+                     void *userData) {
+        size_t nb;
+        if(leafType == &Triangle4v::type) {
+            Triangle4v *prims = reinterpret_cast<Triangle4v *>(node.leaf(nb));
+            BVHPrimitive *primsArray = (BVHPrimitive *)alloca(4 * nb * sizeof(BVHPrimitive));
+            unsigned int realNum = 0;
+            for(int i = 0; i < nb; ++i) {
+                for(size_t j = 0; j < prims[i].size(); j++) {
+                    primsArray[realNum].geomID = prims[i].geomID(j);
+                    primsArray[realNum].primID = prims[i].primID(j);
+                    ++realNum;
+                }
+            }
+
+            return args.createLeaf(realNum, primsArray, userData);
+        } else if(leafType == &Triangle4i::type) {
+            Triangle4i *prims = reinterpret_cast<Triangle4i *>(node.leaf(nb));
+            BVHPrimitive *primsArray = (BVHPrimitive *)alloca(4 * nb * sizeof(BVHPrimitive));
+            unsigned int realNum = 0;
+            for(int i = 0; i < nb; ++i) {
+                for(size_t j = 0; j < prims[i].size(); j++) {
+                    primsArray[realNum].geomID = prims[i].geomID(j);
+                    primsArray[realNum].primID = prims[i].primID(j);
+                    ++realNum;
+                }
+            }
+
+            return args.createLeaf(realNum, primsArray, userData);
+        } else if(leafType == &InstancePrimitive::type) {
+            InstancePrimitive *prims = reinterpret_cast<InstancePrimitive *>(node.leaf(nb));
+            unsigned int *geomIDs = (unsigned int *)alloca(sizeof(unsigned int)*nb);
+            for(int i = 0; i < nb; ++i)
+                geomIDs[i] = prims[i].instance->geomID;
+
+            return args.createInstance(nb, geomIDs, userData);
+        } else if(leafType == &Curve8i::type) {
+            typedef unsigned char Primitive;
+
+            Primitive* prim = (Primitive*)node.leaf(nb);
+            if(nb == 0) return nullptr;
+
+            assert(nb == 1);
+            Geometry::GType ty = (Geometry::GType)(*prim);
+
+            BVHPrimitive primsArray[8];
+            unsigned int realNum = 0;
+
+            switch(ty) {
+            case Geometry::GTY_FLAT_LINEAR_CURVE: {
+                // Access to PrimID from right ISA, otherwise lead to allignement issue
+                DEFINE_ISA_FUNCTION(unsigned int, getLine8iPrimId, Line8i* COMMA unsigned int)
+                SELECT_SYMBOL_INIT_AVX(getCPUFeatures(), getLine8iPrimId)
+
+                Line8i *line = reinterpret_cast<Line8i*>(prim);
+
+                for(size_t i = 0; i < line->m; i++) {
+                    primsArray[realNum].geomID = line->geomID();
+                    primsArray[realNum].primID = getLine8iPrimId(line, i);
+                    ++realNum;
+                }
+            } break;
+            case Geometry::GTY_FLAT_BEZIER_CURVE:
+            case Geometry::GTY_ROUND_BEZIER_CURVE:
+            case Geometry::GTY_ORIENTED_BEZIER_CURVE:
+            case Geometry::GTY_FLAT_BSPLINE_CURVE:
+            case Geometry::GTY_ROUND_BSPLINE_CURVE:
+            case Geometry::GTY_ORIENTED_BSPLINE_CURVE:
+            case Geometry::GTY_FLAT_HERMITE_CURVE:
+            case Geometry::GTY_ROUND_HERMITE_CURVE:
+            case Geometry::GTY_ORIENTED_HERMITE_CURVE: {
+                Curve8i *curve = reinterpret_cast<Curve8i*>(prim);
+                const auto Nb = curve->N;
+                for(size_t i = 0; i < Nb; i++) {
+                    primsArray[realNum].geomID = curve->geomID(Nb);
+                    primsArray[realNum].primID = curve->primID(Nb)[i];
+                    ++realNum;
+                }
+            } break;
+            default:
+                throw_RTCError(RTC_ERROR_INVALID_OPERATION, "Unexpected curve geom type");
+            }
+
+            return args.createCurve(realNum, primsArray, userData);
+        } else if(leafType == &Curve8iMB::type) {
+            typedef unsigned char Primitive;
+
+            Primitive* prim = (Primitive*)node.leaf(nb);
+            if(nb == 0) return nullptr;
+
+            assert(nb == 1);
+            Geometry::GType ty = (Geometry::GType)(*prim);
+
+            BVHPrimitive primsArray[8];
+            unsigned int realNum = 0;
+
+            switch(ty) {
+            case Geometry::GTY_FLAT_LINEAR_CURVE: {
+                // Access to PrimID from right ISA, otherwise lead to allignement issue
+                DEFINE_ISA_FUNCTION(unsigned int, getLine8iPrimId, Line8i* COMMA unsigned int)
+                SELECT_SYMBOL_INIT_AVX(getCPUFeatures(), getLine8iPrimId)
+
+                Line8i *line = reinterpret_cast<Line8i*>(prim);
+
+                for(size_t i = 0; i < line->m; i++) {
+                    primsArray[realNum].geomID = line->geomID();
+                    primsArray[realNum].primID = getLine8iPrimId(line, i);
+                    ++realNum;
+                }
+            } break;
+            case Geometry::GTY_FLAT_BEZIER_CURVE:
+            case Geometry::GTY_ROUND_BEZIER_CURVE:
+            case Geometry::GTY_ORIENTED_BEZIER_CURVE:
+            case Geometry::GTY_FLAT_BSPLINE_CURVE:
+            case Geometry::GTY_ROUND_BSPLINE_CURVE:
+            case Geometry::GTY_ORIENTED_BSPLINE_CURVE:
+            case Geometry::GTY_FLAT_HERMITE_CURVE:
+            case Geometry::GTY_ROUND_HERMITE_CURVE:
+            case Geometry::GTY_ORIENTED_HERMITE_CURVE: {
+                Curve8iMB *curve = reinterpret_cast<Curve8iMB*>(prim);
+                const auto Nb = curve->N;
+                for(size_t i = 0; i < Nb; i++) {
+                    primsArray[realNum].geomID = curve->geomID(Nb);
+                    primsArray[realNum].primID = curve->primID(Nb)[i];
+                    ++realNum;
+                }
+            } break;
+            default:
+                throw_RTCError(RTC_ERROR_INVALID_OPERATION, "Unexpected curve geom type");
+            }
+
+            return args.createCurve(realNum, primsArray, userData);
+        } else {
+            throw_RTCError(RTC_ERROR_INVALID_OPERATION, "Unsupported primitive");
+        }
+    }
 
-      /* if we are in dynamic mode, then do not clear temporary data */
-      if (!(arguments->buildFlags & RTC_BUILD_FLAG_DYNAMIC))
-      {
-        bvh->morton_src.clear();
-        bvh->morton_tmp.clear();
-      }
+    inline RTCBounds boundsToRTC(const BBox3fa &bounds) {
+        RTCBounds bb;
+        bb.lower_x = bounds.lower.x;
+        bb.lower_y = bounds.lower.y;
+        bb.lower_z = bounds.lower.z;
 
-      RTC_CATCH_END(bvh->device);
-      return nullptr;
+        bb.upper_x = bounds.upper.x;
+        bb.upper_y = bounds.upper.y;
+        bb.upper_z = bounds.upper.z;
+
+        bb.align0 = 0;
+        bb.align1 = 1;
+
+        return bb;
     }
 
-    RTC_API void* rtcThreadLocalAlloc(RTCThreadLocalAllocator localAllocator, size_t bytes, size_t align)
-    {
-      FastAllocator::CachedAllocator* alloc = (FastAllocator::CachedAllocator*) localAllocator;
-      RTC_CATCH_BEGIN;
-      RTC_TRACE(rtcThreadLocalAlloc);
-      return alloc->malloc0(bytes,align);
-      RTC_CATCH_END(alloc->alloc->getDevice());
-      return nullptr;
+    template <unsigned int N>
+    inline RTCAffineSpace affineSpaceToRTC(const AffineSpace3vf<N> affSpaces, unsigned int i) {
+      RTCAffineSpace affSpace;
+
+      affSpace.affine[0] = affSpaces.p.x[i];
+      affSpace.affine[1] = affSpaces.p.y[i];
+      affSpace.affine[2] = affSpaces.p.z[i];
+
+      affSpace.linear[0] = affSpaces.l.vx.x[i];
+      affSpace.linear[1] = affSpaces.l.vx.y[i];
+      affSpace.linear[2] = affSpaces.l.vx.z[i];
+      affSpace.linear[3] = affSpaces.l.vy.x[i];
+      affSpace.linear[4] = affSpaces.l.vy.y[i];
+      affSpace.linear[5] = affSpaces.l.vy.z[i];
+      affSpace.linear[6] = affSpaces.l.vz.x[i];
+      affSpace.linear[7] = affSpaces.l.vz.y[i];
+      affSpace.linear[8] = affSpaces.l.vz.z[i];
+
+      return affSpace;
     }
 
-    RTC_API void rtcMakeStaticBVH(RTCBVH hbvh)
-    {
-      BVH* bvh = (BVH*) hbvh;
-      RTC_CATCH_BEGIN;
-      RTC_TRACE(rtcStaticBVH);
-      RTC_VERIFY_HANDLE(hbvh);
-      bvh->morton_src.clear();
-      bvh->morton_tmp.clear();
-      RTC_CATCH_END(bvh->device);
+    template<int N>
+    void* recurse(const typename BVHN<N>::NodeRef node,
+                  const PrimitiveType *leafType,
+                  const RTCBVHExtractFunction args,
+                  void *userData) {
+      if(node.isLeaf())
+          return createLeaf<N>(node, leafType, args, userData);
+
+      const typename BVHN<N>::BaseNode *bnode = nullptr;
+      const typename BVHN<N>::AlignedNode *anode = nullptr;
+      const typename BVHN<N>::AlignedNodeMB *anodeMB = nullptr;
+      const typename BVHN<N>::AlignedNodeMB4D *anodeMB4D = nullptr;
+
+      const typename BVHN<N>::UnalignedNode *unanode = nullptr;
+      const typename BVHN<N>::UnalignedNodeMB *unanodeMB = nullptr;
+
+      if(node.isAlignedNode()) {
+          anode = node.alignedNode();
+          bnode = anode;
+      } else if(node.isAlignedNodeMB()) {
+          anodeMB = node.alignedNodeMB();
+          bnode = anodeMB;
+      } else if (node.isAlignedNodeMB4D()) {
+          anodeMB4D = node.alignedNodeMB4D();
+          anodeMB = anodeMB4D;
+          bnode = anodeMB;
+      } else if (node.isUnalignedNode()) {
+          unanode = node.unalignedNode();
+          bnode = unanode;
+      } else if (node.isUnalignedNodeMB()) {
+          unanodeMB = node.unalignedNodeMB();
+          bnode = unanodeMB;
+      } else {
+          throw_RTCError(RTC_ERROR_INVALID_OPERATION, "Unknown node type");
+      }
+
+      unsigned int nb = 0;
+      void *children[4];
+      for(unsigned int i = 0; i < 4; i++) {
+          void *child = recurse<N>(bnode->child(i), leafType, args, userData);
+          if(child == nullptr) continue;
+
+          if(anode != nullptr) {
+              args.setAlignedBounds(child, boundsToRTC(anode->bounds(i)), userData);
+          } else if (anodeMB != nullptr) {
+              RTCLinearBounds lb;
+              lb.bounds0 = boundsToRTC(anodeMB->bounds0(i));
+              lb.bounds1 = boundsToRTC(anodeMB->bounds1(i) - anodeMB->bounds0(i));
+
+              if (anodeMB4D != nullptr) {
+                  lb.bounds0.align0 = anodeMB4D->timeRange(i).lower;
+                  lb.bounds0.align1 = anodeMB4D->timeRange(i).upper;
+              }
+
+              args.setLinearBounds(child, lb, userData);
+          } else if(unanode != nullptr) {
+              RTCAffineSpace affSpace = affineSpaceToRTC<N>(unanode->naabb, i);
+              args.setUnalignedBounds(child, affSpace, userData);
+          } else if(unanodeMB != nullptr) {
+              RTCAffineSpace affSpace = affineSpaceToRTC<N>(unanodeMB->space0, i);
+
+              RTCBounds bounds;
+              bounds.lower_x = unanodeMB->b1.lower.x[i];
+              bounds.lower_y = unanodeMB->b1.lower.y[i];
+              bounds.lower_z = unanodeMB->b1.lower.z[i];
+
+              bounds.upper_x = unanodeMB->b1.upper.x[i];
+              bounds.upper_y = unanodeMB->b1.upper.y[i];
+              bounds.upper_z = unanodeMB->b1.upper.z[i];
+
+              args.setUnalignedLinearBounds(child, affSpace, bounds, userData);
+          }
+
+          children[nb++] = child;
+      }
+
+      return args.createInnerNode(nb, children, userData);
     }
 
-    RTC_API void rtcRetainBVH(RTCBVH hbvh)
-    {
-      BVH* bvh = (BVH*) hbvh;
-      Device* device = bvh ? bvh->device : nullptr;
-      RTC_CATCH_BEGIN;
-      RTC_TRACE(rtcRetainBVH);
-      RTC_VERIFY_HANDLE(hbvh);
-      bvh->refInc();
-      RTC_CATCH_END(device);
+    std::vector<void*> prerecurse(Accel *a, RTCBVHExtractFunction args, void *userData) {
+      std::vector<void*> nodes;
+
+      AccelData *ad = a->intersectors.ptr;
+      switch(ad->type) {
+      case AccelData::TY_BVH4: {
+        BVH4 *bvh = dynamic_cast<BVH4 *>(ad);
+        BVH4::NodeRef root = bvh->root;
+
+        void* node = recurse<4>(root, bvh->primTy, args, userData);
+        args.setAlignedBounds(node, boundsToRTC(bvh->bounds.bounds()), userData);
+        nodes.push_back(node);
+      } break;
+      case AccelData::TY_BVH8: {
+        BVH8 *bvh = dynamic_cast<BVH8 *>(ad);
+        BVH8::NodeRef root = bvh->root;
+
+        void *node = recurse<8>(root, bvh->primTy, args, userData);
+        args.setAlignedBounds(node, boundsToRTC(bvh->bounds.bounds()), userData);
+        nodes.push_back(node);
+      } break;
+      case AccelData::TY_ACCELN: {
+        AccelN *acceln = dynamic_cast<AccelN *>(ad);
+        for (Accel *acc : acceln->accels) {
+          auto newNodes = prerecurse(acc, args, userData);
+          nodes.insert(nodes.end(), newNodes.begin(), newNodes.end());
+        }
+      } break;
+      default:
+        throw_RTCError(RTC_ERROR_INVALID_OPERATION, "Unable to extract something else than BVH4/8 tree");
+      }
+
+      return nodes;
     }
-    
-    RTC_API void rtcReleaseBVH(RTCBVH hbvh)
-    {
-      BVH* bvh = (BVH*) hbvh;
-      Device* device = bvh ? bvh->device : nullptr;
+
+    RTC_API void *rtcExtractBVH(RTCScene hscene, RTCBVHExtractFunction args, void *userData) {
+      Scene* scene = (Scene*) hscene;
       RTC_CATCH_BEGIN;
-      RTC_TRACE(rtcReleaseBVH);
-      RTC_VERIFY_HANDLE(hbvh);
-      bvh->refDec();
-      RTC_CATCH_END(device);
+      RTC_TRACE(rtcSampleTry);
+#if defined(DEBUG)
+      RTC_VERIFY_HANDLE(hscene);
+#endif
+
+      if (args.expectedSize != nullptr) {
+        /* Defines size and helper macro */
+        struct Size {
+          unsigned int num_prim = 0;
+          unsigned int num_tri = 0;
+        };
+
+#define SIZE(ops)                                 \
+  Size* size = reinterpret_cast<Size*>(userData); \
+  ops                                             \
+  return nullptr;
+
+#define INC(var, val) size->var += (val);
+
+
+        Size size;
+        RTCBVHExtractFunction param;
+
+        param.createLeaf = [](unsigned int nbPrim, const BVHPrimitive[], void* userData) -> void* {
+          SIZE(INC(num_prim, nbPrim) INC(num_tri, 3 * nbPrim))
+        };
+        param.createInstance = [](unsigned int nbPrim, const unsigned int[], void* userData) -> void* {
+          SIZE(INC(num_prim, nbPrim))
+        };
+        param.createCurve = [](unsigned int nbPrim, const BVHPrimitive[], void* userData) -> void* {
+          SIZE(INC(num_prim, nbPrim))
+        };
+        param.createInnerNode = [](unsigned int, void*[], void* ) -> void* { return nullptr; };
+        param.setAlignedBounds = [](void*, const RTCBounds &, void*) {};
+        param.setLinearBounds = [](void*, const RTCLinearBounds &, void*) {};
+        param.setUnalignedBounds = [](void*, const RTCAffineSpace &, void*) {};
+        param.setUnalignedLinearBounds = [](void*, const RTCAffineSpace &, const RTCBounds &, void*) {};
+        param.expectedSize = nullptr;
+
+        prerecurse(scene, param, &size);
+        args.expectedSize(size.num_prim, size.num_tri, userData);
+      }
+
+      std::vector<void*> nodes;
+
+      nodes = prerecurse(scene, args, userData);
+
+      if(nodes.size() == 0)
+        return nullptr;
+
+      if(nodes.size() == 1)
+        return nodes[0];
+
+      RTCBounds bounds;
+      rtcGetSceneBounds(hscene, &bounds);
+
+      void *root = args.createInnerNode(nodes.size(), nodes.data(), userData);
+      args.setAlignedBounds(root, bounds, userData);
+      return root;
+
+      RTC_CATCH_END2(scene);
+      return nullptr;
     }
   }
 }
-
