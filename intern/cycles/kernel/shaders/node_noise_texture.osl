/*
 * Copyright 2011-2013 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "stdosl.h"
#include "vector2.h"
#include "vector4.h"
#include "node_texture.h"

#define vector3 point

/* To compute the color output of the noise, we either swizzle the
 * components, add a random offset {75, 125, 150}, or do both.
 */

float noise(float p, float detail, float distortion, output color Color)
{
  if (distortion != 0.0) {
    p += safe_noise(p + 13.5) * distortion;
  }

  float fac = noise_turbulence(p, detail);
  Color = color(fac, noise_turbulence(p + 75.0, detail), noise_turbulence(p + 125.0, detail));
  return fac;
}

float noise(vector2 p, float detail, float distortion, output color Color)
{
  if (distortion != 0.0) {
    vector2 r;
    r.x = safe_noise(p + vector2(13.5, 13.5)) * distortion;
    r.y = safe_noise(p) * distortion;
    p += r;
  }

  float fac = noise_turbulence(p, detail);
  Color = color(fac,
                noise_turbulence(p + vector2(150.0, 125.0), detail),
                noise_turbulence(p + vector2(75.0, 125.0), detail));
  return fac;
}

float noise(vector3 p, float detail, float distortion, output color Color)
{
  if (distortion != 0.0) {
    vector3 r, offset = vector3(13.5);
    r[0] = safe_noise(p + offset) * distortion;
    r[1] = safe_noise(p) * distortion;
    r[2] = safe_noise(p - offset) * distortion;
    p += r;
  }

  float fac = noise_turbulence(p, detail);
  Color = color(fac,
                noise_turbulence(vector3(p[1], p[0], p[2]), detail),
                noise_turbulence(vector3(p[1], p[2], p[0]), detail));
  return fac;
}

float noise(vector4 p, float detail, float distortion, output color Color)
{
  if (distortion != 0.0) {
    vector4 r, offset = vector4(13.5, 13.5, 13.5, 13.5);
    r.x = safe_noise(p + offset) * distortion;
    r.y = safe_noise(p) * distortion;
    r.z = safe_noise(p - offset) * distortion;
    r.w = safe_noise(vector4(p.w, p.y, p.z, p.x) + offset) * distortion;
    p += r;
  }

  float fac = noise_turbulence(p, detail);
  Color = color(fac,
                noise_turbulence(vector4(p.y, p.w, p.z, p.x), detail),
                noise_turbulence(vector4(p.y, p.z, p.w, p.x), detail));
  return fac;
}

shader node_noise_texture(int use_mapping = 0,
                          matrix mapping = matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                          string dimensions = "3D",
                          vector3 Vector = P,
                          float W = 0.0,
                          float Scale = 5.0,
                          float Detail = 2.0,
                          float Distortion = 0.0,
                          output float Fac = 0.0,
                          output color Color = 0.0)
{
  vector3 p = Vector;
  if (use_mapping)
    p = transform(mapping, p);
  p *= Scale;
  float w = W * Scale;

  if (dimensions == "1D")
    Fac = noise(w, Detail, Distortion, Color);
  else if (dimensions == "2D")
    Fac = noise(vector2(p[0], p[1]), Detail, Distortion, Color);
  else if (dimensions == "3D")
    Fac = noise(p, Detail, Distortion, Color);
  else if (dimensions == "4D")
    Fac = noise(vector4(p[0], p[1], p[2], w), Detail, Distortion, Color);
  else
    error("Unknown dimension!");
}
