/*
 * Copyright 2011-2018 Blender Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "render/denoising.h"

#include "kernel/filter/filter_defines.h"

#include "util/util_foreach.h"
#include "util/util_map.h"
#include "util/util_system.h"
#include "util/util_time.h"

#include <OpenImageIO/filesystem.h>

CCL_NAMESPACE_BEGIN

/****** UTILITY FUNCTIONS ******/

static void print_progress(int num, int total, int frame, int max_frame)
{
	int rows, cols;
	system_console_shape(&rows, &cols);

	cols -= 1;

	int len = 1;
	for(int x = total; x > 9; x /= 10) {
		len++;
	}

	int bars = cols - 2*len - 6;

	printf("\r");

	if(max_frame > 0) {
		int frame_len = 1;
		for(int x = max_frame; x > 9; x /= 10) {
			frame_len++;
		}
		bars -= frame_len + 2;
		printf(" %*d ", frame_len, frame);
	}

	int v = int(float(num)*bars/total);
	printf("[");
	for(int i = 0; i < v; i++) {
		printf("=");
	}
	if(v < bars) {
		printf(">");
	}
	for(int i = v+1; i < bars; i++) {
		printf(" ");
	}
	printf(string_printf("] %%%dd / %d", len, total).c_str(), num);
	fflush(stdout);
}

/* Splits in at its last dot, setting suffix to the part after the dot and in to the part before it.
 * Returns whether a dot was found. */
static bool split_last_dot(string &in, string &suffix)
{
	size_t pos = in.rfind(".");
	if(pos == string::npos) {
		return false;
	}
	suffix = in.substr(pos+1);
	in = in.substr(0, pos);
	return true;
}

/* Separate channel names as generated by Blender.
 * If views is true:
 *   Inputs are expected in the form RenderLayer.Pass.View.Channel, sets renderlayer to "RenderLayer.View"
 * Otherwise:
 *   Inputs are expected in the form RenderLayer.Pass.Channel */
static bool parse_channel_name(string name, string &renderlayer, string &pass, string &channel, bool views)
{
	if(!split_last_dot(name, channel)) {
		return false;
	}
	string view;
	if(views && !split_last_dot(name, view)) {
		return false;
	}
	if(!split_last_dot(name, pass)) {
		return false;
	}
	renderlayer = name;

	if(views) {
		renderlayer += "."+view;
	}

	return true;
}

/****** CHANNEL MAPPINGS ******/

struct ChannelMapping {
	int channel;
	string name;
};

static void fill_mapping(vector<ChannelMapping> &map, int pos, string name, string channels)
{
	for(const char *chan = channels.c_str(); *chan; chan++) {
		map.push_back({pos++, name+"."+*chan});
	}
}

static vector<ChannelMapping> init_input_channels()
{
	vector<ChannelMapping> map;
	fill_mapping(map, 0, "Denoising Depth", "Z");
	fill_mapping(map, 1, "Denoising Normal", "XYZ");
	fill_mapping(map, 4, "Denoising Shadowing", "X");
	fill_mapping(map, 5, "Denoising Albedo", "RGB");
	fill_mapping(map, 8, "Noisy Image", "RGB");
	fill_mapping(map, 11, "Denoising Variance", "RGB");
	fill_mapping(map, 14, "Denoising Intensity", "X");
	return map;
}

static vector<ChannelMapping> init_output_channels()
{
	vector<ChannelMapping> map;
	fill_mapping(map, 0, "Combined", "RGB");
	return map;
}

static const vector<ChannelMapping> input_channels = init_input_channels();
static const vector<ChannelMapping> output_channels = init_output_channels();

/****** RENDERLAYER HANDLING ******/

bool FilterTask::RenderLayer::detect_sets()
{
	buffer_offsets.clear();
	buffer_offsets.resize(channels.size(), -1);

	/* Try to find the offset of each channel that is part of a input set. */
	foreach(const ChannelMapping& mapping, input_channels) {
		vector<string>::iterator i = find(channels.begin(), channels.end(), mapping.name);
		if(i == channels.end()) {
			return false;
		}
		buffer_offsets[i - channels.begin()] = mapping.channel;
	}

	return true;
}

void FilterTask::RenderLayer::generate_map(int buffer_nchannels)
{
	buffer_to_file_map.clear();
	buffer_to_file_map.resize(buffer_nchannels, -1);

	for(int i = 0; i < channels.size(); i++) {
		if(buffer_offsets[i] >= 0) {
			buffer_to_file_map[buffer_offsets[i]] = file_offsets[i];
		}
	}

	/* Check that all buffer channels are correctly set. */
	for(int i = 0; i < buffer_nchannels; i++) {
		assert(buffer_to_file_map[i] >= 0);
	}
}

bool FilterTask::RenderLayer::match_channels(int frame,
                                             const vector<string> &main_channelnames,
                                             const std::vector<string> &frame_channelnames)
{
	assert(frame_buffer_to_file_map.count(frame) == 0);

	int buffer_nchannels = buffer_to_file_map.size();

	vector<int> frame_map(buffer_nchannels, -1);
	for(int i = 0; i < buffer_to_file_map.size(); i++) {
		string channel = main_channelnames[buffer_to_file_map[i]];

		std::vector<string>::const_iterator frame_channel = find(frame_channelnames.begin(), frame_channelnames.end(), channel);

		if(frame_channel == frame_channelnames.end()) {
			printf("Didn't find channel %s in frame %d!\n", channel.c_str(), frame);
			return false;
		}

		frame_map[i] = frame_channel - frame_channelnames.begin();
	}

	frame_buffer_to_file_map[frame] = frame_map;
	return true;
}

void FilterTask::parse_channels(const ImageSpec &in_spec)
{
	const std::vector<string> &channels = in_spec.channelnames;

	out_passthrough.clear();
	out_channels.clear();
	layers.clear();

	/* Loop over all the channels in the file, parse their name and sort them
	 * by RenderLayer.
	 * Channels that can't be parsed are directly passed through to the output. */
	map<string, RenderLayer> file_layers;
	for(int i = 0; i < channels.size(); i++) {
		in_channels.push_back(channels[i]);
		string layer, pass, channel;
		if(!parse_channel_name(channels[i], layer, pass, channel, sd->views)) {
			if(sd->passthrough_unknown) {
				out_passthrough.push_back(i);
				out_channels.push_back(channels[i]);
				printf("Couldn't decode channel name %s, passing through to output!\n", channels[i].c_str());
			}
			else {
				printf("Couldn't decode channel name %s, ignoring!\n", channels[i].c_str());
			}
			continue;
		}
		file_layers[layer].channels.push_back(pass+"."+channel);
		file_layers[layer].file_offsets.push_back(i);
	}

	/* Loop over all detected RenderLayers, check whether they contain a full set of input channels.
	 * Any channels that won't be processed internally are also passed through. */
	for(map<string, RenderLayer>::iterator i = file_layers.begin(); i != file_layers.end(); ++i) {
		RenderLayer &layer = i->second;
		/* Check for full pass set. */

		bool valid_layer = layer.detect_sets();
		if(valid_layer) {
			layer.samples = samples;
			/* If the sample value isn't set yet, check if there is a layer-specific one in the input file. */
			if(layer.samples < 1) {
				string sample_string = in_spec.get_string_attribute("Cycles Samples " + i->first, "");
				if(sample_string != "") {
					if(!sscanf(sample_string.c_str(), "%d", &layer.samples)) {
						printf("Failed to parse samples metadata %s!\n", sample_string.c_str());
					}
				}
			}
			if(layer.samples < 1) {
				printf("No sample number specified in the file for layer %s or on the command line!\n", i->first.c_str());
				continue;
			}

			layer.generate_map(buffer_pass_stride);
			layer.name = i->first;
			layers.push_back(layer);
		}
		if((valid_layer && !sd->passthrough_additional) || (!valid_layer && !sd->passthrough_incomplete)) {
			continue;
		}

		/* Detect unused passes. */
		for(int j = 0; j < layer.buffer_offsets.size(); j++) {
			if(layer.buffer_offsets[j] == -1) {
				/* Special case: Denoising replaces the Combined.RGB channels, so don't pass it through as well. */
				if(valid_layer &&
				   layer.channels[j].substr(0, 9) == "Combined." &&
				   layer.channels[j] != "Combined.A") {
					continue;
				}
				out_passthrough.push_back(layer.file_offsets[j]);
				out_channels.push_back(channels[layer.file_offsets[j]]);
			}
		}
	}


	/* Determine which output channels are produced by each of the processed layers. */
	for(int i = 0; i < layers.size(); i++) {
		/* Determine output channel names. */
		string renderlayer = layers[i].name;
		string view = "";
		if(sd->views) {
			split_last_dot(renderlayer, view);
			view = "."+view;
		}
		const vector<ChannelMapping> &map = output_channels;
		layers[i].out_results.clear();
		layers[i].out_results.resize(map.size());

		/* If the output file will only contain a single set of RGB passes, just use the channel name as it is. */
		only_rgb = (layers.size() == 1) && (!sd->views) && (out_channels.size() == 0);

		for(int j = 0; j < map.size(); j++) {
			layers[i].out_results[map[j].channel] = out_channels.size();
			string pass = map[j].name, channel;
			split_last_dot(pass, channel);
			string name = only_rgb? channel : (renderlayer+"."+pass+view+"."+channel);
			out_channels.push_back(name);
		}
	}
}

/****** TASK HANDLING ******/

bool FilterTask::acquire_tile(Device *device, Device *tile_device, RenderTile &tile)
{
	thread_scoped_lock tile_lock(tiles_mutex);

	if(tiles.empty()) {
		return false;
	}

	tile = tiles.front();
	tiles.pop_front();

	device->map_tile(tile_device, tile);

	print_progress(num_tiles - tiles.size(), num_tiles, center_frame, sd->max_frame);

	return true;
}

/* Mapping tiles is required for regular rendering since each tile has its separate memory
 * which may be allocated on a different device.
 * For standalone denoising, there is a single memory that is present on all devices, so the only
 * thing that needs to be done here is to specify the surrounding tile geometry.
 *
 * However, since there is only one large memory, the denoised result has to be written to
 * a different buffer to avoid having to copy an entire horizontal slice of the image. */
void FilterTask::map_neighboring_tiles(RenderTile *tiles, Device *tile_device)
{
	for(int i = 0; i < 9; i++) {
		if(i == 4) {
			continue;
		}

		int dx = (i%3)-1;
		int dy = (i/3)-1;
		tiles[i].x = clamp(tiles[4].x +  dx   *sd->tile_size.x, 0,  width);
		tiles[i].w = clamp(tiles[4].x + (dx+1)*sd->tile_size.x, 0,  width) - tiles[i].x;
		tiles[i].y = clamp(tiles[4].y +  dy   *sd->tile_size.y, 0, height);
		tiles[i].h = clamp(tiles[4].y + (dy+1)*sd->tile_size.y, 0, height) - tiles[i].y;

		tiles[i].buffer = tiles[4].buffer;
		tiles[i].offset = tiles[4].offset;
		tiles[i].stride = width;
	}

	device_vector<float> *target_mem = new device_vector<float>(tile_device, "denoising_target", MEM_READ_WRITE);
	target_mem->alloc(target_pass_stride*tiles[4].w*tiles[4].h);
	target_mem->zero_to_device();

	tiles[9] = tiles[4];
	tiles[9].buffer = target_mem->device_pointer;
	tiles[9].stride = tiles[9].w;
	tiles[9].offset -= tiles[9].x + tiles[9].y*tiles[9].stride;

	thread_scoped_lock target_lock(targets_mutex);
	assert(target_mems.count(tiles[4].tile_index) == 0);
	target_mems[tiles[9].tile_index] = target_mem;
}

void FilterTask::unmap_neighboring_tiles(RenderTile *tiles)
{
	thread_scoped_lock target_lock(targets_mutex);
	assert(target_mems.count(tiles[4].tile_index) == 1);
	device_vector<float> *target_mem = target_mems[tiles[9].tile_index];
	target_mems.erase(tiles[4].tile_index);
	target_lock.unlock();

	target_mem->copy_from_device(0, target_pass_stride*tiles[9].w, tiles[9].h);

	float *result = target_mem->data();
	float *out = &out_buffer[out_pass_stride*(tiles[9].y*width + tiles[9].x)];
	for(int y = 0; y < tiles[9].h; y++) {
		for(int x = 0; x < tiles[9].w; x++, result += target_pass_stride) {
			for(int i = 0; i < target_pass_stride; i++) {
				out[out_pass_stride*x + layers[current_layer].out_results[i]] = result[i];
			}
		}
		out += out_pass_stride*width;
	}

	target_mem->free();
	delete target_mem;
}

void FilterTask::release_tile()
{
}

bool FilterTask::get_cancel()
{
	return false;
}

DeviceTask FilterTask::create_task()
{
	DeviceTask task(DeviceTask::RENDER);
	task.acquire_tile = function_bind(&FilterTask::acquire_tile, this, device, _1, _2);
	task.map_neighbor_tiles = function_bind(&FilterTask::map_neighboring_tiles, this, _1, _2);
	task.unmap_neighbor_tiles = function_bind(&FilterTask::unmap_neighboring_tiles, this, _1);
	task.release_tile = function_bind(&FilterTask::release_tile, this);
	task.get_cancel = function_bind(&FilterTask::get_cancel, this);
	task.denoising_radius = sd->radius;
	task.denoising_feature_strength = sd->feature_strength;
	task.denoising_strength = sd->strength;
	task.denoising_relative_pca = sd->relative_pca;
	task.pass_stride = buffer_pass_stride;
	task.target_pass_stride = target_pass_stride;
	task.pass_denoising_data = 0;
	task.pass_denoising_clean = -1;
	task.denoising_do_filter = true;
	task.denoising_write_passes = false;
	task.denoising_from_render = false;
	task.frame_stride = buffer_frame_stride;

	task.denoising_frames.resize(frames.size());
	for(int i = 0; i < frames.size(); i++) {
		task.denoising_frames[i] = frames[i]-center_frame;
	}

	thread_scoped_lock tile_lock(tiles_mutex);
	thread_scoped_lock targets_lock(targets_mutex);

	tiles.clear();
	assert(target_mems.empty());
	target_mems.clear();

	int tiles_x = divide_up(width, sd->tile_size.x), tiles_y = divide_up(height, sd->tile_size.y);
	for(int ty = 0; ty < tiles_y; ty++) {
		for(int tx = 0; tx < tiles_x; tx++) {
			RenderTile tile;
			tile.x = tx * sd->tile_size.x;
			tile.y = ty * sd->tile_size.y;
			tile.w = min(width - tile.x, sd->tile_size.x);
			tile.h = min(height - tile.y, sd->tile_size.y);
			tile.start_sample = 0;
			tile.num_samples = layers[current_layer].samples;
			tile.sample = 0;
			tile.offset = 0;
			tile.stride = width;
			tile.tile_index = ty*tiles_x + tx;
			tile.task = RenderTile::DENOISE;
			tile.buffers = NULL;
			tile.buffer = buffer.device_pointer;
			tiles.push_back(tile);
		}
	}
	num_tiles = tiles.size();

	return task;
}

/****** FRAME I/O ******/

static void box_blur(float *data, int w, int h, int s, int r)
{
	array<float> temp(w*h);
	for(int y = 0; y < h; y++) {
		for(int x = 0; x < w; x++) {
			int n = 0;
			float sum = 0.0f;
			for(int dx = max(x-r, 0); dx < min(x+r+1, w); dx++, n++) {
				sum += data[s*(y*w+dx)];
			}
			temp[y*w+x] = sum/n;
		}
	}
	for(int y = 0; y < h; y++) {
		for(int x = 0; x < w; x++) {
			int n = 0;
			float sum = 0.0f;
			for(int dy = max(y-r, 0); dy < min(y+r+1, h); dy++, n++) {
				sum += temp[dy*w+x];
			}
			data[s*(y*w+x)] = sum/n;
		}
	}
}

bool FilterTask::load_file(ImageInput *in_image, const vector<int> &buffer_to_file_map, float *mem, bool write_out)
{
	/* Read all channels of the file into temporary memory.
	 * Reading all at once and then shuffling in memory is faster than reading each channel individually. */
	array<float> raw_image(width*height*nchannels);
	{
		if(!in_image->read_image(TypeDesc::FLOAT, raw_image.data())) {
			return false;
		}
	}

	/* Shuffle image data into correct channels. */
	{
		for(int i = 0; i < height*width; i++) {
			for(int j = 0; j < buffer_pass_stride; j++) {
				mem[i*buffer_pass_stride + j] = raw_image[i*nchannels + buffer_to_file_map[j]];
			}
		}
	}

	if(sd->clamp_input) {
		for(int i = 0; i < height*width*buffer_pass_stride; i++) {
			mem[i] = clamp(mem[i], -1e8f, 1e8f);
		}
	}

	if(write_out) {
		/* Passthrough unused channels directly into the output frame. */
		int passthrough_channels = out_passthrough.size();
		for(int i = 0; i < height*width; i++) {
			for(int j = 0; j < passthrough_channels; j++) {
				out_buffer[i*out_pass_stride + j] = raw_image[i*nchannels + out_passthrough[j]];
			}
		}
	}

	box_blur(mem + 14, width, height, buffer_pass_stride, 5*sd->radius);

	return true;
}

void FilterTask::write_output()
{
	if(sd->ldr_out && only_rgb) {
		for(int i = 0; i < 3*width*height; i++) {
			out_buffer[i] = color_linear_to_srgb(out_buffer[i]);
		}
	}

	out->write_image(TypeDesc::FLOAT, out_buffer.data());
}

bool FilterTask::open_frames(string in_filename, string out_filename)
{
	if(!Filesystem::is_regular(in_filename)) {
		error = "Couldn't find a file called " + in_filename + "!";
		return false;
	}

	in = ImageInput::open(in_filename);
	if(!in) {
		error = "Couldn't open " + in_filename + "!";
		return false;
	}

	const ImageSpec &in_spec = in->spec();
	width = in_spec.width;
	height = in_spec.height;
	nchannels = in_spec.nchannels;

	/* If the sample value isn't set already, check whether the input file contains it. */
	if(samples < 1) {
		string sample_string = in_spec.get_string_attribute("Cycles Samples", "");
		if(sample_string != "") {
			if(!sscanf(sample_string.c_str(), "%d", &samples)) {
				printf("Failed to parse samples metadata %s!\n", sample_string.c_str());
			}
		}
	}

	parse_channels(in_spec);

	if(layers.size() == 0) {
		error = "Didn't find a RenderLayer containing denoising info!";
		return false;
	}

	out = ImageOutput::create(out_filename);
	if(!out) {
		error = "Couldn't open " + out_filename + "!";
		return false;
	}

	assert(!only_rgb || out_channels.size() == 3);

	ImageSpec out_spec(width, height, out_channels.size(), sd->ldr_out? TypeDesc::UINT16 : TypeDesc::FLOAT);
	out_spec.attribute("oiio::ColorSpace", sd->ldr_out? "sRGB" : "Linear");
	out_spec.channelnames.clear();

	/* Set the channels of the output image based on the input parsing result. */
	foreach(string channel, out_channels) {
		out_spec.channelnames.push_back(channel);
	}

	/* Pass through the attributes of the input frame. */
	out_spec.extra_attribs = in_spec.extra_attribs;

	/* Ensure that the output frame contains sample information even if the input didn't. */
	if(!out_spec.find_attribute("Cycles Samples", TypeDesc::STRING)) {
		for(int i = 0; i < layers.size(); i++) {
			string name = "Cycles Samples " + layers[i].name;
			if(!out_spec.find_attribute(name, TypeDesc::STRING)) {
				out_spec.attribute(name, TypeDesc::STRING, string_printf("%d", layers[i].samples));
			}
		}
	}

	out->open(out_filename, out_spec);

	out_pass_stride = out_channels.size();
	out_buffer.resize(width*height*out_pass_stride);

	return true;
}

/****** DENOISER OPERATIONS ******/

bool FilterTask::filter_load(vector<int> frame_range)
{
	buffer_pass_stride = 15;
	target_pass_stride = 3;

	string center_filename = string_printf(in_file.c_str(), center_frame);
	if(!open_frames(center_filename, out_file)) {
		return false;
	}

	foreach(int frame, frame_range) {
		string filename = string_printf(in_file.c_str(), frame);

		if(!Filesystem::is_regular(filename)) {
			printf("Couldn't find frame %s, skipping...\n", filename.c_str());
			continue;
		}

		ImageInput *in_frame = ImageInput::open(filename);
		if(!in_frame) {
			printf("Couldn't open frame %s, skipping...\n", filename.c_str());
			continue;
		}

		const ImageSpec &in_spec = in_frame->spec();
		if(in_spec.width != width || in_spec.height != height) {
			printf("Frame %s has wrong dimensions, skipping...\n", filename.c_str());
			in_frame->close();
			ImageInput::destroy(in_frame);
			continue;
		}

		bool missing_channels = false;
		for(current_layer = 0; current_layer < layers.size(); current_layer++) {
			if(!layers[current_layer].match_channels(frame, in_channels, in_spec.channelnames)) {
				missing_channels = true;
				break;
			}
		}
		if(missing_channels) {
			printf("Frame %s misses channels, skipping...\n", filename.c_str());
			in_frame->close();
			ImageInput::destroy(in_frame);
			continue;
		}

		in_frames.push_back(in_frame);
		frames.push_back(frame);

		if(frames.size() == DENOISE_MAX_FRAMES-1) {
			printf("Reached maximum of %d frames, will skip following ones...\n", DENOISE_MAX_FRAMES);
			break;
		}
	}

	num_frames = in_frames.size()+1;
	buffer_frame_stride = width*height*buffer_pass_stride;

	buffer.alloc(width*buffer_pass_stride, height*num_frames);
	buffer.zero_to_device();

	if(layers.size() == 1) {
		float *buffer_data = buffer.data();
		load_file(in, layers[0].buffer_to_file_map, buffer_data, true);
		for(int i = 0; i < in_frames.size(); i++) {
			buffer_data += buffer_frame_stride;
			load_file(in_frames[i], layers[0].frame_buffer_to_file_map[frames[i]], buffer_data, false);
		}
		buffer.copy_to_device();
	}

	return true;
}

void FilterTask::filter_exec()
{
	bool one_layer = (layers.size() == 1);
	for(current_layer = 0; current_layer < layers.size(); current_layer++) {
		if(!one_layer) {
			float *buffer_data = buffer.data();
			load_file(in, layers[current_layer].buffer_to_file_map,
			          buffer_data, current_layer == 0);
			for(int i = 0; i < in_frames.size(); i++) {
				buffer_data += buffer_frame_stride;
				load_file(in_frames[i],
				          layers[current_layer].frame_buffer_to_file_map[frames[i]],
				          buffer_data, false);
			}
			buffer.copy_to_device();
		}

		DeviceTask task = create_task();
		device->task_add(task);
		device->task_wait();

		printf("\n");
	}
}

void FilterTask::filter_save()
{
	foreach(ImageInput *i, in_frames) {
		i->close();
		ImageInput::destroy(i);
	}

	write_output();
	free();
}

bool FilterTask::run_filter(vector<int> frame_range)
{
	if(!filter_load(frame_range)) {
		return false;
	}
	filter_exec();
	filter_save();
	return true;
}

void FilterTask::free()
{
	buffer.free();
	out_buffer.clear();

	assert(target_mems.empty());

	if(in) {
		in->close();
		ImageInput::destroy(in);
		in = NULL;
	}

	if(out) {
		out->close();
		ImageOutput::destroy(out);
		out = NULL;
	}
}

/****** FILE PATTERN HANDLING AND OUTER LOOP OVER FRAMES ******/

bool StandaloneDenoiser::run_filter()
{
	string in_pattern, in_framestring;
	if(!Filesystem::parse_pattern(in_path.c_str(), 0, in_pattern, in_framestring)) {
		error = "Malformed input pattern!";
		return false;
	}
	if(in_framestring != "") {
		printf("Ignoring input path frame range!\n");
	}

	/* If the output path contains a pattern, substitute the center frame.
	 * Otherwise, just use it as it is. */
	string out_pattern, out_framestring = "";
	if(!Filesystem::parse_pattern(out_path.c_str(), 0, out_pattern, out_framestring)) {
		out_pattern = "";
	}
	else if(out_framestring != "") {
		printf("Ignoring output path frame range!\n");
	}

	if(center_frame == "") {
		error = "No center frame(s) specified!";
		return false;
	}
	std::vector<int> center_frames;
	if(!Filesystem::enumerate_sequence(center_frame, center_frames)) {
		error = "Failed to parse center frame(s)!";
		return false;
	}

	max_frame = 0;
	if(center_frames.size() > 1) {
		foreach(int f, center_frames) max_frame = max(max_frame, f);
	}

	vector<FilterTask*> tasks(center_frames.size(), NULL);
	bool had_error = false;
	for(int i = 0; i < center_frames.size() + 3; i++) {
		thread *save_thread = NULL, *exec_thread = NULL;

		if(i > 2) {
			delete tasks[i-3];
		}

		/* Save the filter result (executed in main thread). */
		if(!had_error && i > 1 && i < (center_frames.size() + 2)) {
			save_thread = new thread(function_bind(&FilterTask::filter_save, tasks[i-2]));
		}

		/* Start thread for executing the filter. */
		if(!had_error && i > 0 && i <= center_frames.size()) {
			exec_thread = new thread(function_bind(&FilterTask::filter_exec, tasks[i-1]));
		}

		/* Start thread for loading the images. */
		if(!had_error && i < center_frames.size()) {
			int frame = center_frames[i];

			/* Determine frame range that should be used for filtering. */
			vector<int> frame_range;
			for(int f = frame - frame_radius; f <= frame + frame_radius; f++) {
				frame_range.push_back(f);
			}

			/* Remove center frame from list of secondary frames. */
			vector<int>::iterator center_frame_iter = find(frame_range.begin(), frame_range.end(), frame);
			if(center_frame_iter != frame_range.end()) {
				frame_range.erase(center_frame_iter);
			}

			string out_filename = out_path;
			if(out_pattern != "") {
				out_filename = string_printf(out_pattern.c_str(), frame);
			}
			tasks[i] = new FilterTask(device, this, in_pattern, out_filename, frame);
			if(!tasks[i]->filter_load(frame_range)) {
				error += tasks[i]->error;
				had_error = true;
			}
		}

		if(exec_thread) {
			exec_thread->join();
			delete exec_thread;
		}

		if(save_thread) {
			save_thread->join();
			delete save_thread;
		}
	}

	return !had_error;
}

CCL_NAMESPACE_END